//////// 1. What are the ELF magic numbers?

They are the first 4 bytes of an ELF file that is used to identify that the file is an ELF. 
	/* For e_ident[EI_MAG0..3] */
	#define	ELFMAG0		0x7f
	#define	ELFMAG1		'E'
	#define	ELFMAG2		'L'
	#define	ELFMAG3		'F'


//////// 2. What is the difference between UIO_USERISPACE and UIO_USERSPACE? When should one use UIO_SYSSPACE instead?

As found on line 102 of loadelf.c 
	u.uio_segflg = is_executable ? UIO_USERISPACE : UIO_USERSPACE;

UIO_USERISPACE i.e. the user process code is used when a file is executable. UIO_USERSPACE i.e. the user process data is used when a file is not executable.
UIO_SYSSPACE should be used when the data transfer happens within the kernel space.


//////// 3. Why can the struct uio that is used to read in a segment be allocated on the stack in load_segment() (i.e., where does the memory read actually go)?

The struct uio just holds information about the data transfer including information about the filesize, offset etc. not the actual data itself. The memory read actually goes into the address that the struct uio contains


//////// 4. In runprogram(), why is it important to call vfs_close() before going to usermode?

Considering that we do not need the file anymore, it is best practice to close the file before moving to usermode. If we do not close it, we risk causing a memory leak.


//////// 5. What function forces the processor to switch into usermode? Is this function machine dependent?

This function is `enter_new_process` defined in `kern/arch/mips/locore/trap.c`. And, it is a machine dependent function


//////// 6. In what file are copyin and copyout defined? memmove? Why can't copyin and copyout be implemented as simply as memmove?

copyin and copyout are defined in `kern/vm/copyinout.c`
memmove is defined in `common/libc/string/memmove.c`
Copyin and copyout cannot be simply implemented as memmove even though all 3 are used for transfer data, since the prior functions need to assure the block of user memory provided (an address and a length) falls within the proper userspace region. 


//////// 7. What (briefly) is the purpose of userptr_t?

The purpose of userptr_t is to specify that the address is relative to an address in users-space.


//////// 8. What is the numerical value of the exception code for a MIPS system call?

The numerical value of the exception code for a MIPS system call is: 8


//////// 9. How many bytes is an instruction in MIPS? (Answer this by reading syscall() carefully, not by looking somewhere else.)

At the end of syscall the program counter stored in the tapframe, tf->tf_epc, is incremented by 4-bytes to avoid restarting  the syscall over and over again. Therefore an instruction in MIPS is 4 bytes.


//////// 10. Why do you "probably want to change" the implementation of kill_curthread()?

We will want to change the current implementation of kill_curthread(), because currently it panics and does not kill the thread when user-level code hits a fatal fault..


//////// 11. What would be required to implement a system call that took more than 4 arguments?

In situations like this it will be required to fetch the further arguments from the user level stack  starting at sp+16.


//////// 12. What is the purpose of the SYSCALL macro?

The purpose of the syscall macro is to load the syscall number into the right register (v0) and then jump to the shared syscall code. 


//////// 13. What is the MIPS instruction that actually triggers a system call? (Answer this by reading the source in userland/lib/libc/arch/mips, not looking somewhere else.)

`syscall` is the instruction that actually triggers a system call.


//////// 14. After reading syscalls-mips.S and syscall.c, you should be prepared to answer the following question: OS/161 supports 64-bit values; lseek() takes and returns a 64-bit offset value. Thus, lseek() takes a 32-bit file handle (arg0), a 64-bit offset (arg1), a 32-bit whence (arg2), and needs to return a 64-bit offset value. In void syscall(struct trapframe *tf) where will you find each of the three arguments (in which registers) and how will you return the 64-bit offset?

In this situation we will find arg0 in register a0. Since arg1 is 64-bit it must be passed in an aligned pair of registers, so it will be found in a2 and a3, and a1 will be unused. And arg2 must be fetched from the user level stack starting at sp+16.
We will return the 64-bit offset in registers v0 and v1.


//////// 15. As you were reading the code in runprogram.c and loadelf.c, you probably noticed how the kernel manipulates the files. Which kernel function is called to open a file? Which macro is called to read the file? What about to write a file? Which data structure is used in the kernel to represent an open file? 

The kernel function called to open a file is `vfs_open`. The macro used to read a file is VOP_READ, and the one used to write to a file is VOP_WRITE. The structure used in the kernel to represent an open file is vnode


//////// 16. What is the purpose of VOP_INCREF and VOP_DECREF?

VOP_INCREF increases the reference count for a given file by calling the function vnode_incref. VOP_DECREF decreases the reference count for a given file by calling the function vnode_decref.
